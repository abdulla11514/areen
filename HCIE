\\ lec 1 //

---> Transaction Isolation 
--> Open session1, begin a transaction, insert data, and query the data.
begin; 
delete from tb1;
insert into tb1(att1,att2) values(2,2); 
select * from tb1; 
-> Open session2 and query table tb1.
select * from tb1;
-> Commit the transaction in session1.
commit; 
-> In session2, continue to query table tb1.
 select * from tb1;

--->  Transaction Consistency
--> Create a transaction order table, insert data, and initialize the payer's account balance to CNY20 and the store's account balance to CNY500.
create table orders(name varchar(32), amount integer);
insert into orders values('customer', 20);
insert into orders values('shop', 500); 
SELECT * FROM ORDERS;

--> After initialization, begin a transaction, and simulate a transaction in which the person pays CNY10 and the store's account receives CNY10.
begin;
update orders set amount=10 where name='customer'; 
update orders set amount=510 where name='shop';
 select * from orders;

--> Commit the transaction.
commit;

---> READ COMMITTED 
--> Dirty read.
Open two windows: session1 and session2. The default isolation level of the database is 
READ COMMITTED. Therefore, you do not need to reset the isolation level of the 
database. 
1. Query table tb2 in session1. The query result is empty.
2. Start a transaction in session2 and insert data.
3. Query table tb2 in session1. The result is still empty. 
4. Commit the transaction in session2. 
5. Query table tb2 in session1. You can see the data inserted in session2.
Session1:
begin; 
select * from tb2; 
 
Session2:
begin; 
insert into tb2 values(1,1); 
select * from tb2;
commit;
select * from tb2;

---> REPEATABLE READ
--> Open two windows: session1 and session2. The default isolation level of the database is 
READ COMMITTED. Therefore, you do not need to reset the isolation level of the 
database. 
1. Set the isolation levels of session1 and session2 to REPEATABLE READ and view the 
isolation levels. 
2. Start a transaction in session1 and query table tb3. The query result is empty. 
3. Start a transaction in session2 and insert data. 
4. Query table tb3 in session1. The result is still empty. 
5. Commit the transaction in session2. 
6. Query table tb3 in session1. The query result is still empty.

Session1: 
set 
default_transaction_isolation= 'REPEATABLE READ';    
show transaction_isolation;    
begin;
select * from tb3;
insert into tb3 values(1,1); 
select * from tb3;
select * from tb3; 

Session2: 
set
default_transaction_isolation='REPEATABLE READ';
show transaction_isolation; 
begin;
commit; 


--->Subtransactions
-->  BEGIN...END 
BEGIN 
INSERT INTO tb4 VALUES(1,1); 
INSERT INTO tb4 VALUES(2,2); 
UPDATE TEST SET att1=3, att2=3 WHERE att1=1; 
RAISE INFO 'ERROR OCCURS'; 
END; 
INSERT INTO tb4 VALUES(4,4); 
END; 

-->  BEGIN...SAVEPOINT...COMMIT/ROLLBACK
CREATE TABLE tb5(att1 int,att2 int); 
begin;
INSERT INTO tb5 VALUES(1,1);
SAVEPOINT S1; 
INSERT INTO tb5 VALUES(2,2); 
INSERT INTO tb5 VALUES(3,3);

--> Roll back to the savepoint S1. If the data inserted after the savepoint S1 does not exist, the rollback to S1 is successful. 
ROLLBACK TO SAVEPOINT S1;
SELECT * FROM tb5;

--> Create savepoint S2.
SAVEPOINT S2;
INSERT INTO tb5 VALUES(4,4);
ROLLBACK TO SAVEPOINT S2;

--> Release savepoint S2. 
RELEASE SAVEPOINT S2;
SELECT * FROM tb5;

--> Create savepoint S3. 
SAVEPOINT S3; 
INSERT INTO tb5 VALUES(5,5);
RELEASE SAVEPOINT S3; 

---> Viewing Lock Information
--> Check the ID of the current session.
SELECT pg_backend_pid( );

--> Search for the lock added to the current session.
SELECT locktype,database,relation,pid,mode FROM pg_locks WHERE pid= 281450093779312; 

--> Query the relation ID of table tb6. 
 SELECT oid FROM pg_class WHERE relname='tb6'; 

---> Reproducing a Shared Lock
--> Start a transaction and place a shared lock.
BEGIN;
CREATE INDEX idx_att1 ON tb6(att1);
SELECT locktype,database,relation,pid,mode FROM pg_locks WHERE pid= 281450093779312; 

--> Perform the INSERT operation. 
 insert into tb6 values(2,2);

--> Perform the SELECT operation.
select * from tb6; 

--> Commit the transaction and release the shared lock.
commit;
insert into tb6 values(2,2); 

---> Reproducing ACCESS SHARE Locks
--> Query the PID of the current session. 
SELECT pg_backend_pid( );

--> Start a transaction, query the table, and place a lock.
BEGIN; 
SELECT * FROM tb6;
SELECT locktype,database,relation,pid,mode FROM pg_locks WHERE pid= 281449887013232; 

--> Perform the SELECT operation. 
SELECT * FROM tb6; 

--> Perform the ALTER operation.
 alter table tb6 add(att3 varchar(10));

--> Commit the transaction and release the lock.
commit;
alter table tb6 add(att3 varchar(10));

---> Reproducing a ROW EXCLUSIVE Lock  
--> Query the PID of the current session.
SELECT pg_backend_pid( ); 

--> Start a transaction, modify table data, and place a lock.
begin;
UPDATE tb6 SET att1 = 3 ,att2 = 3 where att1=1;
SELECT locktype,database,relation,pid,mode FROM pg_locks WHERE pid= 281449887013232; 

--> Perform the CREATE INDEX operation.
CREATE INDEX idx_att2 ON tb6(att2); 

-->Commit the transaction in the first session. 
commit;
CREATE INDEX idx_att2 ON tb6(att2); 

---> Reproducing an ACCESS EXCLUSIVE Lock 
--> Query the PID of the current session.
SELECT pg_backend_pid( );

--> Start a transaction, modify the table structure, and place a lock.
BEGIN;
ALTER TABLE tb6 ADD(att4 varchar(10)); 
SELECT locktype,database,relation,pid,mode FROM pg_locks WHERE pid=281449983678832; 

--> Perform the SELECT operation. 
SELECT * FROM tb6;

--> Commit the transaction in the first session.
commit;
SELECT * FROM tb6;

\\ lec 2 //

---> Storage Management
--> Compiling a Database  la root amana anwsen
sed -i s/gpgcheck=1/gpgcheck=0/g /etc/yum.repos.d/openEuler.repo 
yum -y install -y readline-devel
yum -y install libaio-devel 
yum -y install bison 
yum -y install flex

--> Create a user group and user for compiling the database.
groupadd gsgrp
useradd -g gsgrp -u 1001 -d /home/gslab gslab 

--> Set a password of the gslab user.
passwd gslab

--> Log in as the gslab user
su - gslab 

--> Create the opengauss-compile directory for compiling openGauss. 
mkdir opengauss-compile
cd opengauss-compile/

--> You can run the wget command on the ECS to download the package. 
wget  https://opengauss.obs.cn-south-1.myhuaweicloud.com/3.0.0/openGauss-third_party_binarylibs.tar.gz

--> Decompress the openGauss source code package openGauss-server-v3.0.0.zip.
unzip openGauss-server-v3.0.0.zip 

--> Decompress the third-party library binary package openGauss third_party_binarylibs.tar.gz. 
tar -zxvf openGauss-third_party_binarylibs.tar.gz 

--> Rename the directory of the third-party library binary package to binarylibs-v3.0.0.
mv openGauss-third_party_binarylibs binarylibs-v3.0.0 

--> Use the vim editor to edit the ~/.bashrc file and add environment variables. 
vim ~/.bashrc

--> Configure the following environment variables in the .bashrc file: 
export CODE_BASE=/home/gslab/opengauss-compile/openGauss-server-v3.0.0 # Path of the 
openGauss-server file 
export BINARYLIBS=$CODE_BASE/../binarylibs-v3.0.0 
export GAUSSHOME=$CODE_BASE/dest 
export GCC_PATH=$BINARYLIBS/buildtools/openeuler_aarch64/gcc7.3 
export CC=$GCC_PATH/gcc/bin/gcc 
export CXX=$GCC_PATH/gcc/bin/g++ 
export 
LD_LIBRARY_PATH=$GAUSSHOME/lib:$GCC_PATH/gcc/lib64:$GCC_PATH/isl/lib:$GCC_PATH/mpc/lib/:
$GCC_PATH/mpfr/lib/:$GCC_PATH/gmp/lib/:$LD_LIBRARY_PATH 
export PATH=$GAUSSHOME/bin:$GCC_PATH/gcc/bin:$PATH 

--> Run the source command for the environment variables to take effect. 
source ~/.bashrc

--> Go to the openGauss-server directory and prepare for compilation.
cd openGauss-server-v3.0.0

--> Run the configure script to perform the configuration before compilation. To perform debugging, set the version to debug. 
./configure --gcc-version=7.3.0 CC=g++ CFLAGS='-O0' -prefix=$GAUSSHOME --3rd=$BINARYLIBS --enable-debug --enable-cassert --enable-thread-safety --with-readline --without-zlib  


--> Run the make command to perform compilation. The -j4 option of the make command specifies parallel compilation using 4 processes.
make -j4
make clean

--> Install openGauss. 
make install

--->Starting openGauss
--> Initialize the database.  Run the following gs_initdb command to initialize openGauss:
gs_initdb --pgdata=$GAUSSHOME/data -- nodename=dblab --encoding=utf-8
--> start database
gs_ctl start -D $GAUSSHOME/data -Z single_node -l logfile

--> Check the running status of the database server.
gs_ctl status -D $GAUSSHOME/data

--> (Optional) To stop the database server, run the following command: 
gs_ctl stop -D $GAUSSHOME/data -Z single_node -l logfile

--> Connect to the database.
gsql postgres -r

---> Installing the pageinspect Plug-in 
--> Go to the pageinspect directory. 
cd /home/gslab/opengauss-compile/openGauss-serverv3.0.0/contrib/pageinspect

--> View the file content in the pageinspect directory. 
ll

--> Compile the pageinspect plug-in. 
make

--> Install the pageinspect plug-in.
make install 

--> Change the password of the gslab user. Log in to the postgres database and change the password of the gslab user. 
ALTER ROLE gslab password 'openGauss@123';

 --> Create the pageinspect plug-in in the postgres database
CREATE EXTENSION pageinspect; 

--> Check whether pageinspect is successfully installed.
SELECT * FROM pg_extension; 

--> Using the pageinspect Plug-in to Analyze the Page Structure of a Table 
CREATE TABLE tb7(att1 int,att2 int);
-->Viewing the Page Header Structure of a Table
SELECT* FROM page_header(get_raw_page('tb7', 0));  this line erorr
--> Insert the first tuple and view the page header structure. 
INSERT INTO tb7 VALUES(1,1);
--> Run the following statement to view the page header structure:
SELECT* FROM page_header(get_raw_page('tb7', 0)); 
--> Insert the second tuple and view the page header structure.
INSERT INTO tb7 VALUES(2,2);
--> Run the following statement to view the page header structure: 
SELECT* FROM page_header(get_raw_page('tb7', 0));
--> Insert the last seven tuples and check the page header structure. 
INSERT INTO tb7 VALUES(3,3); 
INSERT INTO tb7 VALUES(4,4); 
INSERT INTO tb7 VALUES(5,5); 
INSERT INTO tb7 VALUES(6,6); 
INSERT INTO tb7 VALUES(7,7); 
INSERT INTO tb7 VALUES(8,8); 
INSERT INTO tb7 VALUES(9,9);
--> Run the following statement to view the page header structure: 
SELECT* FROM page_header(get_raw_page('tb7', 0));

---> Viewing Tuple Data on a Page
--> Run the following command to view tuple data on a page: 
SELECT * FROM heap_page_items(get_raw_page('tb7', 0)); 

---> Viewing Original Data on a Page 
--> Run the following command to view original data on a page: 
SELECT get_raw_page::text FROM get_raw_page('tb7', 0); 

// lec 3 \\















