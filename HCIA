--> lec-2  Database and Object Management

--> Create a tablespace
create tablespace test_tbs LOCATION '/opt/opengauss/tablespace/test_tbs1';

--> Create a user
create user jack IDENTIFIED BY 'xxxxxxxx'; 

--> grant the user the permissions to access the test_tbs tablespace. 
GRANT CREATE ON TABLESPACE test_tbs TO jack; 

--> Create a table in the test_tbs tablespace
create table test (id int) tablespace test_tbs; 

--> Check the pg_tablespace system catalog.  
SELECT spcname FROM pg_tablespace; 

--> View all the tablespaces defined by the system and users. 
\db 

--> Query the tablespace usage.
-> Query the current usage of the tablespace. The result indicates the size of the tablespace, in bytes.
SELECT PG_TABLESPACE_SIZE('test_tbs'); 

--> Modify the tablespace.
->Run the following command to rename the tablespace:
ALTER TABLESPACE test_tbs RENAME TO test_tbs1;

--> Delete a tablespace.  # abe table bsretawa amja tablespace asretawa
drop table test; 
drop tablespace test_tbs1; 

---> Creating, Viewing, Modifying, and Deleting a Database:
--> Create the testdb database in the db_tbs tablespace. 
CREATE DATABASE testdb with  TABLESPACE = db_tbs;

--> View a database. 
1) SELECT datname FROM pg_database;
2)  \l 

---> Modify a database.
--> Modify the default search path of the database. 
ALTER DATABASE testdb SET search_path TO pa_catalog,public;

--> Change the database tablespace. 
ALTER DATABASE testdb SET tablespace db_tbs1;

--> Rename the database. 
ALTER DATABASE testdb RENAME TO testdb1; 

--> Delete a database. 
DROP DATABASE testdb1;

---> Creating, Viewing, Modifying, and Deleting Row-store Tables, Column-store Tables, and MOTs 
--> Create a row-store table. By default, the table is a row-store table, that is, WITH (ORIENTATION = ROW) can be omitted.
CREATE TABLE PART 
( .... ) 
WITH (ORIENTATION = ROW); 

--> Create a column-store table.
CREATE TABLE PART1 
( ..... ) 
WITH (ORIENTATION = COLUMN);

--> View the table information. 
\d

---> Modify table attributes. 
--> Adds a column. 
ALTER TABLE part ADD COLUMN p_col1 bigint;

--> Add the default value in the column. 
ALTER TABLE part ALTER COLUMN p_col1 SET DEFAULT 1;

--> Delete the default value in the column. 
ALTER TABLE part ALTER COLUMN p_col1 drop DEFAULT ;

--> Change the data type of a column. 
ALTER TABLE part MODIFY p_col1 INT;

--> Rename a column. 
 ALTER TABLE part RENAME p_col1 to p_col; 

--> Deletes a column. 
ALTER TABLE part DROP COLUMN p_col; 

--> Create an MOT. 
 create FOREIGN table test(x int) ;  # agar ama erorr ya ama awam code anwsen la omm'akaya
-> gs_guc set -N all -I all -c "enable_incremental_chec=off"

--> Create an index for the MOT. 
create index  text_index1 on test(x) ;

--> Delete a table. 
DROP TABLE PART; 

---> User, Role, and Schema Management 
--> Check the user list. 
 SELECT * FROM pg_user; 

--> For a user having the Create Database permission, add the CREATEDB keyword: 
CREATE USER dim CREATEDB PASSWORD 'Bigdata@123';

--> Change the login password of jim from Bigdata@ to Abcd@123.
ALTER USER jim IDENTIFIED BY 'Abcd@123' REPLACE 'Bigdata@123';

--> Grant the CREATEROLE permission to user jim.
 ALTER USER jim CREATEROLE; 

--> Lock the jim account: 
ALTER USER jim ACCOUNT LOCK; 

--> Unlock the jim account. 
ALTER USER jim ACCOUNT UNLOCK; 

--> Delete a user.
DROP USER jim CASCADE;

---> Role Management
--> Create role manager whose password is Bigdata123@.
CREATE ROLE manager IDENTIFIED BY 'Bigdata@123'; 

--> Create a role. The role takes effect from July 1, 2020 and expires on December 1, 2020. 
CREATE ROLE miriam WITH LOGIN PASSWORD 'Bigdata@123' VALID BEGIN '2020-07-01' VALID UNTIL '2020-12-01'; 

--> Change role manager to the system administrator: 
ALTER ROLE manager SYSADMIN; 

--> Delete the role manager. 
DROP ROLE manager;

--> View the roles. 
SELECT * FROM PG_ROLES; 

---> Schema Management 
--> Create the ds schema
 CREATE SCHEMA ds;

--> Rename the ds schema to ds_new.
ALTER SCHEMA ds RENAME TO ds_new;

--> Create a user named jack. 
CREATE USER jack PASSWORD 'Bigdata@123'; 

--> Change the owner of ds_new to jack. 
ALTER SCHEMA ds_new OWNER TO jack; 

--> View the schema owner.
SELECT s.nspname,u.usename AS nspowner FROM pg_namespace s, pg_user u WHERE s.nspowner = u.usesysid; 

--> Delete user jack and the ds_new schema
 DROP SCHEMA ds_new;
 DROP USER jack; 

---> Granting System Permissions to Users or Roles
--> user joe and grant the sysadmin permissions to the user.
Create CREATE USER joe PASSWORD 'Bigdata@123';
ALTER USER joe with sysadmin;

---> Granting Database Object Permissions to Roles or Users
--> Revoke the sysadmin permission of user joe,
ALTER USER joe with nosysadmin; 
-->  create the tpcds schema
CREATE SCHEMA tpcds;
--> create a reason table for the tpcds schema
 CREATE TABLE tpcds.reason 
( .... );
--> Grant the usage permission on the tpcds schema
GRANT USAGE ON SCHEMA tpcds TO joe;
--> all the permissions on the tpcds.reason table to the user joe.
GRANT ALL PRIVILEGES ON tpcds.reason TO joe;

--> Grant the query permission on r_reason_sk, r_reason_id, and r_reason_desc columns and 
the update permission on the r_reason_desc column in the tpcds.reason table to user joe. 
GRANT select (r_reason_sk,r_reason_id,r_reason_desc),update (r_reason_desc) ON tpcds.reason TO joe; 

--> Grant the postgres database connection permission and schema creation permission to user 
joe, and enable this user to grant these permissions to other users. 
GRANT create,connect on database postgres TO joe WITH GRANT OPTION; 

--> Create role tpcds_manager, grant the tpcds schema access permission and object creation 
permission to this role, but do not enable this role to grant these permissions to others.
CREATE ROLE tpcds_manager PASSWORD 'Bigdata@123'; 
GRANT USAGE,CREATE ON SCHEMA tpcds TO tpcds_manager; 

---> Granting the Permissions of One User or Role to Others 
--> Create the manager role, grant joe's permissions to manager
CREATE ROLE manager PASSWORD 'Bigdata@123'; 
--> allow manager to grant these permissions to others
GRANT joe TO manager WITH ADMIN OPTION; 

--> grant manager's permissions to senior_manager.
 GRANT manager TO senior_manager; 

---> Revoking Permissions
--> Revoke permissions and delete users. 
REVOKE manager FROM joe; 
REVOKE senior_manager FROM manager;
DROP USER manager; 
REVOKE ALL PRIVILEGES ON tpcds.reason FROM joe;
REVOKE ALL PRIVILEGES ON SCHEMA tpcds FROM joe; 
REVOKE USAGE,CREATE ON SCHEMA tpcds FROM tpcds_manager;
DROP ROLE tpcds_manager; 
DROP ROLE senior_manager;
DROP USER joe CASCADE; 

---> Data Import and Export
---> Creating a Backup Directory
--> Create a backup directory as user omm.
mkdir /gaussdb/backup 
cd /gaussdb/backup 

--> Creating a Table and Inserting Data
->  CREATE TABLE customer_t1 
postgres-# ( 
postgres(#     c_customer_sk             integer, 
postgres(#     c_customer_id             char(5), 
postgres(#     c_first_name              char(6), 
postgres(#     c_last_name               char(8) 
postgres(# ); 

NSERT INTO customer_t1 (c_customer_sk, c_customer_id, c_first_name) VALUES 
postgres-# (3769, 'hello', DEFAULT) , 
postgres-#     (6885, 'maps', 'Joes'), 
postgres-#     (4321, 'tpcds', 'Lily'), 
postgres-# (9527, 'world', 'James'); 

--> View data in the customer_t1 table
select * from customer_t1; 

--> Display information about the current table
\d 

---> Exporting Data Using the copy Command
-> Switch to the default user omm. 
\c - omm 
-> Run the copy command to export data.
copy customer_t1 to '/gaussdb/backup/copy_cost.txt' delimiter '^';
\q 
-> View the exported file.  ama la omm anawse
cd /gaussdb/backup/ 
ll
-> Exporting Data Using the gs_dump Command 
gs_dump -U omm -W Bigdata@123 -f /gaussdb/backup/gsdump_post.sql -p 26000 postgres -F p 

--> Use gs_dump to export the postgres database data in .tar format.
gs_dump -U omm -W Bigdata@123 -f /gaussdb/backup/gsdump_post.tar -p 26000 postgres -F t 
ll

--> Use gs_dump to export tables-dependent views.
-> Connect to the database, create the vw_customer_t1 view that depends on the customer_t1 table, and exit.
gsql -d postgres -p 26000 –r 
create view vw_customer_t1 as select * from customer_t1 limit 2; 
\q
-> Export the vw_customer_t1 view that depends on the customer_t1 table. 
gs_dump -s -p 26000 postgres -t PUBLIC.customer_t1 --include-depend-objs --exclude self -f /gaussdb/backup/view_cust.sql -F p

--> Exporting Data Using the gs_dumpall Command
-> Use gs_dumpall to export all openGauss databases at a time. 
gs_dumpall -f  /gaussdb/backup/gsdumpall.sql -p 26000

--> Importing Data Using the gsql Command
-> Delete the exported tables.
gsql -p 26000 postgres -r 
drop table joe.mytable;
drop table public.customer_t1 cascade; 
\q 

-> Use gsql to restore the exported table. (Ignore "ERROR:  schema "joe" already exists".) 
gsql -p 26000 postgres -r -f /gaussdb/backup/gsdump_post.sql 
-> Check the restored table.
gsql -p 26000 postgres -r 
select * from joe.mytable;
select * from public.customer_t1;
\q 

--> Importing Data Using the copy Command 
-> Delete the tables that have been exported by running the copy command
gsql -p 26000 postgres -r 
truncate table public.customer_t1; 
-> Run the copy command to import data. 
copy customer_t1 from '/gaussdb/backup/copy_cost.txt' delimiter '^';
-> View the imported table data.
select * from customer_t1; 

--> Importing Data Using the gs_restore Command
-> Delete the tables and views exported using gs_dump. 
gsql -p 26000 postgres -r 
drop table joe.mytable; 
drop table public.customer_t1;
-> Use gs_restore to import data from the gsdump_post.tar file to the tpcc database. 
create database tpcc; 
\q
-> Import data from the gsdump_post.tar file to the tpcc database. 
gs_restore /gaussdb/backup/gsdump_post.tar -p 26000 -d tpcc 
-> Log in to the tpcc database and view the restored data.
gsql -p 26000 tpcc -r
select * from public.customer_t1;
select * from joe.mytable; 

--> Clearing the Lab Environment 
-> Delete the created database user. 
gsql -p 26000 postgres -r
\l
 drop database tpcc; 
\du
drop user joe;
\q


// lec 3 \\

--> Querying Data 
-->Use an asterisk (*) after SELECT to query all columns in the bank_card table. 
SELECT * FROM bank_card;   

--> Check the bank card number and card type in the bank_card table.
SELECT b_number,b_type FROM bank_card;

--> View the ID, name, email address, and bank card number of customer 1.
SELECT a.c_id,a.c_name, a.c_mail, b.b_number FROM client a, bank_card b where a.c_id= 1 and b.b_c_id = 1; 

 -->  Use an alias. 
SELECT b_c_id AS CardID, b_type CardType FROM bank_card; 

--> Conditional Query 
--> Query information about a credit card in the bank_card table
SELECT * FROM bank_card WHERE b_type= 'Credit Card'; 


-->  Query information about a credit card whose customer ID is 1 from the bank_card table. 
SELECT * FROM bank_card where b_c_id= 1and b_type='Credit Card'; 

---> Join Query
-->  Use an inner join to query tables. Query the customer ID, bank card number, and bank card type. 
-> Use the (c_id) column of the client and bank_card tables to perform the query operation.
SELECT c.c_id, b.b_number, b.b_type FROM client c JOIN bank_card b ON (b.b_c_id = c.c_id); 

-->  Use the left outer join to query the customer ID, user name, bank card number, and bank card type. 
SELECT c.c_id,c.c_name, b.b_number,b.b_type FROM client c left join bank_card b on c.c_id=b.b_c_id;                          

--> Use the right outer join to query data in the client and bank_card tables.
SELECT c.c_id,c.c_name, b.b_number,b.b_type FROM client c right join bank_card b on c.c_id =b.b_c_id;                        

--> Obtain the full join data of the client and bank_card tables through a full join. 
SELECT c.c_id,c.c_name, b.b_number,b.b_type FROM client c FULL JOIN bank_card b ON (b.b_c_id = c.c_id); 

---> Data Sorting
--> Query the names, amounts, and target people of insurances with insurance numbers higher than 2 in descending order.
SELECT i_name,i_amount,i_person FROM insurance WHERE i_id>2 ORDER BY i_amount DESC; 

---> Data Limit 
--> Query the insurance information in the following table. Add LIMIT 2 OFFSET 1 to skip the first row and query a total of two rows
SELECT i_name, i_id, i_amount, i_person FROM insurance LIMIT 2 OFFSET 1; 

---> Updating Data 
--> Insert data into the bank_card table.
INSERT INTO bank_card(b_number, b_type, b_c_id) VALUES ('6222022302020000030','Savings Card', 30); 
INSERT INTO bank_card(b_number, b_type, b_c_id) VALUES ('6222022302020000031','Savings Card', 31); 
INSERT INTO bank_card(b_number, b_type, b_c_id) VALUES ('6222022302020000032','Savings Card', 32);  

-->  Insert all data from the bank_card table into the bank_card1 table using a subquery.
CREATE TABLE bank_card1(b_number NCHAR(30) PRIMARY KEY, b_type NCHAR(20), b_c_id INT NOT NULL); 
INSERT INTO bank_card1 SELECT * FROM bank_card; 

-->  Insert a record and update a value for columns in which this primary key is a duplicate. 
INSERT INTO bank_card VALUES ('6222022302020000001', 'Credit Card', 1) ON DUPLICATE KEY UPDATE b_type = 'Savings Card';


--> Query records in the bank_card table. 
SELECT * FROM bank_card;  

-->  Update the record whose customer ID is 1 in the bank_card table and change the value of b_type to Credit Card. 
UPDATE bank_card SET bank_card.b_type = 'Credit Card' where b_c_id=1; 

---> Deleting Data 
--> Delete the records, whose b_type is Credit Card and b_c_id is 1, from the bank_card table
DELETE FROM bank_card WHERE b_type='Credit Card' AND b_c_id=1; 

--> Query records in the bank_card table.
SELECT * FROM bank_card;                                                                                                     

-->  Delete all data from the bank_card table.
DELETE FROM bank_card; 

--> Query records in the bank_card table.
SELECT * FROM bank_card;   

---> Defining Data
--> Change the maximum number of connections to database music.
ALTER DATABASE music WITH CONNECTION LIMIT 30; 

--> Rename the database. 
ALTER DATABASE music RENAME TO music01; 

--> Change the default tablespace of the database. 
CREATE TABLESPACE tablespace01 RELATIVE LOCATION 'tablespace01/tablespace_01'; 
ALTER DATABASE music01 SET TABLESPACE tablespace01;

--> Change the database owner
ALTER DATABASE music01 OWNER TO jim01; 

---> Deleting a Database
--> Delete a database.
DROP DATABASE music01; 

--> Delete users. 
DROP USER jim;  
DROP USER jim01; 

---> Defining a Schema 
--> Rename the schema.
ALTER SCHEMA role1 RENAME TO role1_new;  

--> Change the owner of the schema. 
ALTER SCHEMA role1_new OWNER TO jack; 

-->  Deleting a Schema 
DROP SCHEMA role1_new; 

--->  Defining a Table
--> Temporary table 
CREATE TEMPORARY TABLE bank_card2(b_number NCHAR(30) PRIMARY KEY, b_type NCHAR(20),b_c_id INT NOT NULL); 

--> Rename the bank_card table to bank_card1. 
ALTER TABLE bank_card RENAME TO bank_card1; 

--> Add a column to the bank_card1 table. The data type is Integer.
ALTER TABLE bank_card1 ADD full_masks INTEGER; 

-->  Change the data type of a column. 
ALTER TABLE bank_card1 MODIFY full_masks NVARCHAR2(20);

--> Add a constraint. 
ALTER TABLE bank_card1 ADD CONSTRAINT ck_bank_card CHECK(b_c_id>0); 
ALTER TABLE bank_card1 ADD CONSTRAINT uk_bank_card UNIQUE(full_masks); 

--> Delete a column.
ALTER TABLE bank_card1 DROP full_masks; 

-->  Insert data into a table. If the constraint is not met, an error is reported. 
INSERT INTO bank_card1(b_number, b_type, b_c_id) VALUES ('6222022302020000001','Credit Card', 0); 

---> Deleting Data from a Table
-->  Delete all rows from the bank_card1 table. 
DELETE FROM bank_card1; 

-->  Deleting a Table 
DROP TABLE IF EXISTS bank_card1; 

---> Defining a Partitioned Table
--> Create a tablespace and a partitioned table
CREATE TABLESPACE example1 RELATIVE LOCATION 'tablespace1/tablespace_1'; 

--> Modify a tablespace of a partitioned table
ALTER TABLE bank_card MOVE PARTITION bank_card1 TABLESPACE example3;  

-->  Rename the partitioned table. 
ALTER TABLE bank_card RENAME PARTITION bank_card1 TO bank_card5; 

--> Combine partitions.
ALTER TABLE bank_card MERGE PARTITION bank_card1, bank_card2 INTO PARTITION bank_card3;  

--> Delete a partition
ALTER TABLE bank_card DROP PARTITION bank_card4;

---> Creating an Index
-->  Create an index on b_number, b_type in the bank_card table.
CREATE INDEX idx_bank_card ON bank_card(b_number ASC,b_type);

--> Create the education partitioned table. 
 CREATE TABLE education(staff_id INTEGER NOT NULL, higest_degree CHAR(8), graduate_school 
VARCHAR(64),graduate_date DATETIME, education_note VARCHAR(70)) 
PARTITION BY LIST(higest_degree) 
( 
PARTITION doctor VALUES ('Doctor'), 
PARTITION master VALUES ('Master'), 
PARTITION undergraduate VALUES ('Bachelor') 
);

-->  Create a partitioned index with the name of the index partition specified. 
CREATE INDEX idx_education ON education(staff_id ASC, higest_degree) LOCAL (PARTITION doctor, PARTITION master, PARTITION undergraduate); 

---> Modifying an Index 
--> Rebuild the index. 
ALTER INDEX idx_bank_card REBUILD;

--> Rename an index.
ALTER INDEX idx_bank_card RENAME TO idx_bank_card_temp; 

--> Set an index as unusable.
ALTER INDEX idx_bank_card UNUSABLE; 

--> Delete the idx_bank_card index from the bank_card table.
DROP INDEX idx_bank_card; 

--> Run the CREATE VIEW command to create a view. 
CREATE OR REPLACE VIEW privilege_view AS SELECT b_number, b_type FROM bank_card; 

--> Query the data in the view. The syntax is the same as that for querying a table. 
SELECT * FROM privilege_view; 

--> Query the view structure
\d privilege_view; 

--> Creating a Sequence 
CREATE SEQUENCE seq_auto_extend START WITH 10 MAXVALUE 200 INCREMENT BY 2 CYCLE; 

--> Query the next value of seq_auto_extend.
SELECT seq_auto_extend.NEXTVAL FROM DUAL; 

---> Modifying a Sequence
-->  Set INCREMENT BY to 4 and MAXVALUE to 400. 
ALTER SEQUENCE seq_auto_extend MAXVALUE 400 INCREMENT BY 4 CYCLE; 

--> Delete the seq_auto_extend sequence.
DROP SEQUENCE IF EXISTS seq_auto_extend; 

--> Arithmetic Functions and Operators 
SELECT 2+3,2*3, @ -5.0, 2.0^3.0, |/ 25.0, 91&15, 17#5,1<<4 AS RESULT; 
SELECT abs(-10),cos(0),sin(0),acos(1),asin(0); 

-->  bitand(exp1,exp2) performs an AND (&) operation on two digits. 
SELECT bitand(29,15); 

--> Time and date operators (–)
SELECT date '2022-5-28' + integer '7' AS RESULT; 
SELECT date '2022-05-28' + interval '1 hour' AS RESULT;  
SELECT date '2022-05-28' + time '03:00' AS RESULT;  
SELECT interval '1 day' + interval '1 hour' AS RESULT;  
SELECT date '2022-05-01' - date '2022-04-28' AS RESULT;  
SELECT date '2022-05-01' - integer '7' AS RESULT;  
SELECT date '2022-05-28' - interval '1 hour' AS RESULT;  
SELECT time '05:00' - interval '2 hours' AS RESULT;  
SELECT age(timestamp '2001-04-10', timestamp '1957-06-13'); 
SELECT current_time; 

--> Type Conversion Functions
SELECT to_char(125, '999'),to_clob('hello111'::CHAR(15)),to_date('05 Dec 2000', 'DD Mon YYYY'), 
to_number('12,454.8-', '99G999D9S'); 

-->  cast(x as y) converts x to the type specified by y. 
SELECT cast('22-oct-1997' as timestamp); 

-->  hextoraw(string) converts a hexadecimal string to RAW. 
SELECT hextoraw('7D');

// lec 4 \\
skip

// lec 5 \\
































