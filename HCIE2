/**/CH5/**/

--->DB Optimization
-> Checking the Server Hardware
uname -a
->Checking the CPU
top  //and press 1
us:
ni:
sy:
wa:
st:
id:
// dway amana press Shift+M to sort the results by memory.
->check memory
[root@server1 ~]# free -h
->Checking the OS Version
[root@server1 ~]# cat /etc/os-release
->Checking the Network Status
[root@server1 ~]#sudo yum install nginx
[root@server1 ~]# sudo yum install sysstat
[root@ecs-444 ~]# sar -n DEV 3 2
-> Checking the I/O Status
[root@server1 ~]# iostat -xm 3 2
->query key parameter
openGauss=# show max_process_memory;
openGauss=# show shared_buffers;
openGauss=# show work_mem;

---> Optimizing SQL Queries Using a Vectorized Executor
create tb ,insert data
->Enable the time
openGauss=# \timing on
-> Disable the vectorized executor
openGauss=# show try_vector_engine_strategy;
openGauss=# set try_vector_engine_strategy to off;
-> Run the query statement
openGauss=# select count(1) from (select t1.a from vector_t1 t1 left join vector_t2 t2 on t1.a = t2.a);
-> Enable the vectorized
openGauss=# set try_vector_engine_strategy to force;
-> Restore parameter 
openGauss=# \timing off
openGauss=# reset try_vector_engine_strategy;

--->SMP-related
crerate tb,insert data,timeing on'ka
openGauss=# reset query_dop;
openGauss=# show query_dop;
-> run query in normal mode
openGauss=# select count(1) from smp_t1 where a > 100000;
->Set query_dop to 4 to enable parallel
openGauss=# set query_dop = 4;
/*/agar rest parameter wist time off ka enja restkarawa

--->GUC Parameter Setting and Plan Hints
create tb,insert data
->Run explain to print
openGauss=# explain select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Disable the costs display.
openGauss=# explain(costs off) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Print an execution plan in verbose mode
openGauss=# explain(verbose) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
-> execution plan in analyze
openGauss=# explain analyze select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Print the CPU usage.
openGauss=# explain(analyze on, CPU on) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Print the usage of the buffer
openGauss=# explain(analyze on, buffers on) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Specify the output format
openGauss=# set explain_perf_mode = 'normal';
openGauss=# explain(format json) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
openGauss=# explain(analyze, format json) select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
->Print an execution plan in performance
openGauss=# explain performance select t1.a from exp_t1 t1 full join exp_t2 t2 on t1.a = t2.a where t1.a < 10000;
/*/if performance is used,u can drop the tables

--->Printing an Execution Plan in Rollback Mode
create tb,
-> Print an execution plan using INSERT in normal mode
openGauss=# explain insert into exp_fallback_t1 values(1, 1);
openGauss=# select * from exp_fallback_t1;
->using UPDATE
openGauss=# insert into exp_fallback_t1 values (1, 1);
openGauss=# select * from exp_fallback_t1;
-> using DELETE 
openGauss=# insert into exp_fallback_t1 values (1, 1);
openGauss=# explain delete from exp_fallback_t1;
openGauss=# select * from exp_fallback_t1;

->using INSERT in analyze mode.
openGauss=# explain analyze insert into exp_fallback_t1 values(100, 100);
-> UPDATE in analyze mode
openGauss=# explain analyze update exp_fallback_t1 set a = 200, b = 200;

--->Setting GUC Parameters to Optimize an Execution Plan
create 3 tb,
declare
n1 numeric := 100;
n2 numeric := 0;
n3 numeric := 100;
begin
while n1 > 0 loop
 n2 := 0;
 while n2 < 100 loop
 n3 := 100;
 while n3 > 0 loop
 insert into btm_t1 values(n1, n2, n3);
 insert into btm_t2 values(n1, n3, n2);
 insert into btm_t3 values(n2, n1, n3); 
n3 := n3 - 1;
 end loop;
 n2 := n2 + 1;
 end loop;
 n1 := n1 - 1;
end loop;
end;
/
->create index
create index idx_btm_11 on btm_t1 using btree (a);
create index idx_btm_12 on btm_t1 using btree (b);
create index idx_btm_13 on btm_t1 using btree (c);
create index idx_btm_21 on btm_t2 using btree (a);
create index idx_btm_22 on btm_t2 using btree (b);
create index idx_btm_23 on btm_t2 using btree (c);
create index idx_btm_31 on btm_t3 using btree (a);
create index idx_btm_32 on btm_t3 using btree (b);
create index idx_btm_33 on btm_t3 using btree (c);
->Disable enable_bitmapscan
openGauss=# set enable_bitmapscan to off;
openGauss=# explain (costs off) select * from btm_t1 t1, btm_t2 t2, btm_t3 t3
where t1.a = t2.b and t2.a = t3.c and t3.a = t1.c and t1.a = 1 and t2. a = 1 and t3.a = 1;
->enable bitmascan enja haman query bnusarawa

---> enable_tidscan
create tb,insert data like above , desable tidscan,
openGauss=# explain analyze select * from tid_t1 where ctid = '(0,10)'::tid;
openGauss=# set enable_tidscan to on;
openGauss=# explain analyze select * from tid_t1 where ctid = '(0,10)'::tid;

->enable_indexonlyscan
create tb,create index to tb,insert data,disable indexo
openGauss=# explain analyze select a, b from testidx_t1 where a = 10 and b = 20;
enable indexo
openGauss=# explain analyze select a, b from testidx_t1 where a = 10 and b = 20;
openGauss=# drop table testidx_t1;
openGauss=# reset enable_indexonlyscan;

--->Scenarios Where GUC Parameters Cannot Affect an Execution Plan
openGauss=# create table employee(id int, deptid int);
openGauss=# create table manager(id int, deptid int);
openGauss=# insert into employee values(1, 1), (2,1),(3,2),(4, 1), (5,2);
openGauss=# insert into manager values(1,1), (2,2),(3,1),(4,2);
openGauss=# set enable_nestloop to off;
openGauss=# explain SELECT * FROM employee e JOIN manager m ON e.deptid < m.deptid;
openGauss=# reset enable_nestloop;
openGauss=# drop table employee;

--->Using Plan Hints on an Execution Plan
openGauss=# create table t1(c1 number,c2 number,c3 number);
openGauss=# create table t2(c1 number,c2 number,c3 number);
openGauss=# insert into t1 values(generate_series(1,10000), 2 ,3);
openGauss=# insert into t2 values(generate_series(1,10000), 2, 3);
openGauss=# explain analyze select * from t1 join t2 on t1.c1 = t2.c2;
openGauss=# explain analyze select/*+ mergejoin(t1 t2) */ * from t1 join t2 on t1.c1 = t2.c2;
///drop tables

--->Poor Plan Hints Increase the Time Consumption
create,insert
openGauss=# explain analyze select * from t1 join t2 on t1.c1 = t2.c2;
openGauss=# explain analyze select/*+ nestloop(t1 t2) */ * from t1 join t2 on t1.c1 = t2.c2;

--->Optimizing openGauss Indexes
crete tb,insert data,timg on,
openGauss=# select * from t1 where a > 1000 and a < 1003;
create index on t1(a)
openGauss=# \timing on
openGauss=# select * from t1 where a > 1000 and a < 1003;
openGauss=# \timing off

--->Optimizing Table Structures
-> Selecting Proper Storage Types
openGauss=# \timing on
create two tb,insert data
openGauss=# explain analyze select * from row_t where a > 100 and a < 1000;
openGauss=# explain analyze select * from col_t where a > 100 and a < 1000;
->Selecting Proper Partition Types
create table student_t1 (
id int,
name varchar(20),
score int
) partition by range(id) (
partition s1p1 values less than (100000),
partition s1p2 values less than (200000)
);
create table student_t2 (
id int,
name varchar(20),
score int
) partition by hash(id) (
partition s1p1,
partition s1p2
);
openGauss=# insert into student_t1 values (generate_series(1,499999), 1, generate_series(50, 100));
openGauss=# insert into student_t2 values (generate_series(1, 499999), 1, generate_series(50, 100));
openGauss=# explain analyze select * from student_t1 where id = 9999;
openGauss=# explain analyze select * from student_t1 where id > 100 and id < 1000;  //range query

---> CBO
create tb,insert data genreate
openGauss=# explain analyze select a, b, c from test1 where a > 20000 and a < 200000;
openGauss=# vacuum analyze test1;     /*/vacuum perform
openGauss=# explain analyze select a, b, c from test1 where a > 20000 and a < 200000;
openGauss=# Delete from test1;
DELETE 5000000
openGauss=# insert into test1 values (generate_series(1, 5000), generate_series(1, 1000), 'hello' ||
random()); 
openGauss=# vacuum analyze test1;         /*/perform vacuum
--->Modifying Cost Parameters
create tb,insert generate data,
openGauss=# reset seq_page_cost;
RESET
openGauss=# show seq_page_cost;
openGauss=# explain select a, b, c from test1 where a > 20000 and a < 200000;
openGauss=# set seq_page_cost to 10;       /*/modify seqpage

--->Diagnosing SQL Performance
->Useing WDR
openGauss=# alter system set enable_wdr_snapshot to on;
openGauss=# select * from snapshot.snapshot;
create tb,insert generate data
openGauss=# select count(1) from test1;
openGauss=# select count(1) , b, max(a) from test1 group by b order by b limit 5;
openGauss=# select create_wdr_snapshot();
openGauss=# select * from snapshot.snapshot;
openGauss=# \a \t \o ~/my_wdr_report.html                          /*/Adjust the output format and specify the WDR output file.
select generate_wdr_report(3, 4, 'all', 'cluster', null);          /*/ Generate a WDR.
openGauss=# \o \a \t         /*/Restore to the initial output

---> Optimizing Subqueries
->Correlated Subqueries and Non-correlated Subqueries












